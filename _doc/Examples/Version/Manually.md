---
layout: doc
title: Automatic Version Numbering
permalink: /doc/Examples/Version/Manually/
---
# Automatic Version Numbering

![Sample of class]({{site.docp}}/Resources/examples/VersionClass.gif)

{% assign infoData = "You can also use the **[<span class='glyphicon glyphicon-indent-left' aria-hidden='true'></span> Wizard](../Wizard/#how-to)**. *Easy steps for quick results.*" %}
{% include elem/info %}

{% assign infoColor = "#5C9ECF" %}
{% assign infoData = "The easiest manual way **[here](../Simple/)**." %}
{% include elem/info %}

Before reading, **please note**: You can achieve this (or similar) result with [our different modes]({{site.docp}}/Modes/). 

For simplicity, we'll consider [Script Mode]({{site.docp}}/Modes/Script/). But you can also try with [Targets Mode]({{site.docp}}/Modes/Targets/) or [C# Mode]({{site.docp}}/Modes/CSharp/), or even with [simple caller]({{site.docp}}/Features/Confirmation dialog/) and [others]({{site.docp}}/Examples/).

## Synopsis

This method will generate automatically the Version class like this â†˜

```csharp
public struct EvMSBuildVersion
{
    public static readonly Version number = new Version(S_NUM_REV);

    public const string S_NUM = "1.14.1";
    public const string S_REV = "0";

    public const string S_NUM_REV = S_NUM + "." + S_REV;

    public const string B_SHA1 = "";

    internal const string S_PRODUCT = S_NUM_REV + "";
    internal const string S_INFO    = S_PRODUCT + "+" + B_SHA1;
}
```

*For C++ you can also use preprocessor directives #define (macro definitions):*

```cpp
#pragma once

#ifndef VSSBE_VERSION_H_
#define VSSBE_VERSION_H_

#define VER_BRANCH_NAME     "develop";
#define VER_BRANCH_SHA1     "e3de826";
#define VER_BRANCH_REVCOUNT "296";
#define VER_INFORMATIONAL   "0.12.4.17639+e3de826";

#endif
```

or C++ struct similar to C# above:

```cpp
struct RXWVersion
{
    struct TNum
    {
        const int major;
        const int minor;
        const int patch;
        const int build;

        TNum(int major, int minor, int patch, int build = 0)
            : major(major), minor(minor), patch(patch), build(build) { }

        TNum() : TNum(1, 3, 0, 3411) { }

    } number;

    const TCHAR* bSha1      = _T("f3bd722");
    const TCHAR* config     = _T("PublicRelease");
    const TCHAR* product    = _T("1.3.0");
};
```

**Then,** you can easily use this in various places or even provide as API.

Attributes: 

```csharp
[InstalledProductRegistration("#110", "#112", Version.numberWithRevString, IconResourceID = 400)]
```

AssemblyInfo:

```csharp
[assembly: AssemblyVersion(Version.numberString)]
```

Other places, for example:

```csharp
toolVersion.Text = $"v{Version.numberString}+{Version.branchSha1}";
```

What about static files?

For example, **.vsixmanifest** is a xml-based file used in [VSPackages (VSIX)](https://msdn.microsoft.com/en-us/library/bb166424.aspx).

Since we can't use this directly as above, we can just update this 'as is', for example, using regex or simple placeholders. For example: 

```{{site.sbelang1}}
#[IO replace.Regexp("source.extension.vsixmanifest", "<Version>[0-9.]+</Version>", "<Version>$(number)</Version>")]
```
Where, `$(number)` it's your version number (see [MSBuild]({{site.docp}}/Scripts/MSBuild/) and [UserVariableComponent]({{site.docp}}/Scripts/SBE-Scripts/Components/UserVariableComponent/)). You can manage this value with the following options:

* Getting from [MSBuild Property]({{site.docp}}/Scripts/MSBuild/) `#[var number = $(name)]` or `$(number = $(name))`
* Getting from file: `#[var number = #[File get(".version")]]`
* Getting from your external tool(stdout): `#[var number = #[IO sout("updv.exe", "-s new")]]`
* Manually set: `#[var number = 1.2.3]` or `$(number = "1.2.3")`
* Other with [MSBuild]({{site.docp}}/Scripts/MSBuild/) & [SBE-Scripts]({{site.docp}}/Scripts/SBE-Scripts/)
* etc.

**Note:** The `<Version>` in .vsixmanifest follows the CLR assembly versioning format: Major.Minor.Build.Revision (1.2.40308.00). see MSDN:

* [VSIX Extension Schema 2.0 Reference](http://msdn.microsoft.com/en-us/library/hh696828.aspx)
* [System.Version](http://msdn.microsoft.com/en-us/library/System.Version%28v=vs.110%29.aspx)

## Generating the Version class with build/revision number

Create template of Version class or struct.

1. Either use external file such as *Version.tpl* **or** define data **inside script**, etc.
1. Either use placeholders **or** evaluate actual values.

For example,

```csharp
#[var tpl = // This code was generated by a vsSolutionBuildEvent. 
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
namespace net.r_eg.EvMSBuild
{
    using System;

    public struct EvMSBuildVersion
    {
        public static readonly Version number = new Version(S_NUM_REV);

        public const string S_NUM = "#[$(pVer)]";
        public const string S_REV = "#[$(revBuild)]";

        public const string S_NUM_REV = S_NUM + "." + S_REV;

        public const string B_SHA1 = "#[$(bSha1)]";

        internal const string S_PRODUCT = S_NUM_REV + "$(postfixRel)";
        internal const string S_INFO    = S_PRODUCT + "+" + B_SHA1;
    }
}]
```

You can also use some external file to store a common version in your repo like `.version`. **Or** just use some variables like `$(Version)` etc.

* Select event type - "Pre-Build".
* Change "Processing mode" to 'Script Mode'
* Activate [SBE-Scripts]({{site.docp}}/Scripts/SBE-Scripts/) support
* Activate [MSBuild]({{site.docp}}/Scripts/MSBuild/) support
* Write the following script, for example:

```{{site.sbelang}}
#[$(revDeltaBase  = "2015/12/02")]
#[$(revDeltaMin   = $([System.Math]::Pow(10, 3)))]
#[$(revDeltaMax   = 65534)] #[" limit of AssemblyVersion (2^16 - 2) "]

#[var tBase     = $([System.DateTime]::Parse('$(revDeltaBase)').ToBinary())]
#[var tNow      = $([System.DateTime]::UtcNow.Ticks)]
#[var revBuild  = #[$(
    [System.TimeSpan]::FromTicks('$(
        [MSBuild]::Subtract($(tNow), $(tBase))
    )')
    .TotalMinutes.ToString('0')    
)]]
                        
#[var revBuild  = #[$(

    [MSBuild]::Add(
        $(revDeltaMin), 
        $([MSBuild]::Modulo(
            $(revBuild), 
            $([MSBuild]::Subtract(
                $(revDeltaMax), $(revDeltaMin)
            ))
        ))
    )
    
)]]

#[" 
    Checking of the git to define sha1, branch name, etc.
"]
#[var isGit = #[IO cmd("git rev-parse 2>&1")]]
#[( $(isGit) == "" )
{
    #[var bSha1 = #[IO sout("git", "rev-parse --short HEAD")]]
}
else {
    #[$(bSha1 = '')]
}]


#[var tpl = // This code was generated by a vsSolutionBuildEvent. 
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
namespace net.r_eg.EvMSBuild
{
    using System;

    public struct EvMSBuildVersion
    {
        public static readonly Version number = new Version(S_NUM_REV);

        public const string S_NUM = "#[$(pVer)]";
        public const string S_REV = "#[$(revBuild)]";

        public const string S_NUM_REV = S_NUM + "." + S_REV;

        public const string B_SHA1 = "#[$(bSha1)]";

        internal const string S_PRODUCT = S_NUM_REV + "$(postfixRel)";
        internal const string S_INFO    = S_PRODUCT + "+" + B_SHA1;
    }
}]

#[$(pVerPub = "$(pVer).$(revBuild)$(postfixRel)")]
#[$(pVerPrint = "$(pVerPub)+$(bSha1)")]
#[$(pVerProd = "$(pVer)$(postfixRel)")]

#[" Finalize your data in file system "]

#[File write("src/EvMSBuildVersion.cs"):#[$(tpl.Replace('\n', '\r\n'))]]

#[IO replace.Regex("src/E-MSBuild.csproj", "<Version>.+?</Version>", "<Version>$(pVerProd)</Version>")]
```

Activate event and click apply. Enjoy.

*See also - [Custom counters]({{site.docp}}/Features/Custom counters/) & [Date & Time]({{site.docp}}/Features/Date & Time/) features for details about limitations for revBuild if you work in team.*

As result you will see **EvMSBuildVersion.cs** as above (must be included in main project with `Build Action` as `Compile`) and **E-MSBuild.csproj** file with updated number.

Also you can configure revision number only for specific configurations, for example:

```{{site.sbelang}}
#[( $(Configuration) == "PublicRelease" )
{
    #[$(pVerPub = "$(pVer).$(revBuild)+$(bSha1)")]
}]
```
In example above should be like 1.14.1.**34073+014f49a** only for **PublicRelease** configuration and 1.14.1 for others.

* `1.14.1.30337`
* `1.14.1.30337+014f49a API 1.4`

To get revBuild in range (see [Math]({{site.docp}}/Features/Math/)), you can use for example:

* 0 - 99999:

```{{site.sbelang}}
#[var revBuild  = ...]
#[var revBuild  = $([MSBuild]::Modulo(#[var revBuild], 100000))]
```

* n - m (e.g. 1000 - 99999):

Same as above, only use limit like: 
```
 = (val % (max - min)) + min
```

```{{site.sbelang}}
#[$(
    [MSBuild]::Add(
        $(minrev), 
        $([MSBuild]::Modulo(
            $(rev), 
            $([MSBuild]::Subtract(
                $(maxrev), 
                $(minrev)
             ))
        ))
    )
)]
```

You can test/debug all scripts with our testing tools, find it in `Settings` - `Tools`

### Wizard or "help me, it's so hard"

ok, try the [**Wizard** for the most common solutions](../Wizard/#how-to).

# Examples of real projects

It is actively used for the following projects:

* [regXwild](https://github.com/3F/regXwild)
    * [Sample of build ![](https://img.shields.io/badge/Build30-passing-brightgreen.svg?style=flat)](https://ci.appveyor.com/project/3Fs/regxwild-github/builds/34562551)

* [7z.Libs](https://github.com/3F/7z.Libs)
* [MvsSln](https://github.com/3F/MvsSln)
* [Conari](https://github.com/3F/Conari)
* [DllExport](https://github.com/3F/DllExport)
* [hMSBuild](https://github.com/3F/hMSBuild)
* [LuNari](https://github.com/3F/LuNari)
* [GetNuTool](https://github.com/3F/GetNuTool)
* [vsSolutionBuildEvent](https://github.com/3F/vsSolutionBuildEvent)
* ...

## Fully Automatic Versions and Sequential numbers

*Any generating of the numbers can be whatever you want, see for example [Increment & Decrement Numbers]({{site.docp}}/Features/Custom counters/)*

Some projects and [CI]({{site.docp}}/CI/) can use basic numbering such as 1, 2, 3, 4 .. 99, 100, 101 ... 500, 501 etc.

That's why you need understand where to store the common number between environments. Moreover, most CI servers already provides **special environment variables** like `$(appveyor_build_version)`, `$(BUILD_NUMBER)`, etc. You can combine this or [Increment this]({{site.docp}}/Features/Custom counters/) as you want !

```{{site.msblang}}
$(buildNumber += 1)
or
$(buildNumber = $([MSBuild]::Add($(buildNumber), 1)))
```

# References

* [Processing modes]({{site.docp}}/Modes/)
* [Math operations]({{site.docp}}/Features/Math/)
* [Custom counters]({{site.docp}}/Features/Custom counters/)
* [Date & Time]({{site.docp}}/Features/Date & Time/)
* [SBE-Scripts]({{site.docp}}/Scripts/SBE-Scripts/)
* [MSBuild]({{site.docp}}/Scripts/MSBuild/)
* [Visual Studio Gallery page]({{site.lnkVSGallery}})
* [Wizard variant](../Wizard/)
* [Examples & Features]({{site.docp}}/Examples/)





<!-- Actual date for user script above -->
<script>
    var rand = function(min, max)
    {
        return Math.round(Math.random() * (max - min) + min);
    };

    var datePrint = function(date)
    {
        var m = date.getMonth() + 1; // 0 - 11: 0 is Jan
        var d = date.getDate();      // 1 - 31

        return date.getFullYear() + '/' + (m < 10 ? '0' + m : m) + '/' + (d < 10 ? '0' + d : d);
    };

    var date = new Date();
    date.setDate(date.getDate() - rand(2, 30));
    $(".highlighter-rouge .s:contains('2015/12/02')").html('"' + datePrint(date) + '"');
</script>