# Automatically updating version number for VSIX Package (vsixmanifest) #

## Variant with your utility as part of solution ##

### Synopsis ###

This method should automatically generate the class, e.g.: ↘


```
#!C#

// This code was generated by a tool
class Version
{
    public static readonly System.Version number    = new System.Version(0, 8, 0, 118696);
    public const string numberWithRevString         = "0.8.0.118696";
    public const string numberString                = "0.8.0";
    public const string branchName                  = "master";
    public const string branchSha1                  = "f4c5546";
    public const string branchRevCount              = "88";
}
```
Then, we can use this in different places:

• For VSIX Package, sample: 
```
#!C#

[InstalledProductRegistration("#110", "#112", Version.numberWithRevString, IconResourceID = 400)]
```

• For AssemblyInfo, sample:

```
#!C#

[assembly: AssemblyVersion(Version.numberString)]
```

• Other places, e.g:

```
#!C#

  toolVersion.Text = string.Format("v{0} [ {1} ]", Version.numberString, Version.branchSha1);
  etc.,
```


For **.vsixmanifest** it's a little harder. The <Version> in .vsixmanifest, follows the CLR assembly versioning format: Major.Minor.Build.Revision (1.2.40308.00). see MSDN:

* [VSIX Extension Schema 2.0 Reference](http://msdn.microsoft.com/en-us/library/hh696828.aspx)
* [System.Version](http://msdn.microsoft.com/en-us/library/System.Version%28v=vs.110%29.aspx)
    
therefore, we can update this only as replacement, see below


### Step 1. Preparing utility ###

The next steps:

* Create in your solution any project (on C++/C#/VB ... not important) for controlling version of main application.
* Create template of Version class e.g.: Version.tpl with what you want, using placeholders instead of real values - sample:


```
#!C#

// Version.tpl:
namespace Example
{
    class Version
    {
        public static readonly System.Version number    = new System.Version(%Version%);
        public const string branchSha1                  = "%branchSha1%";
        ...
    }
}
```

* Now you can create any handler for work with current template. Basically you need simple implement:
* * Loading Version.tpl
* * Replacement all using placeholders on real data
* * Replacement the section of <version></version> in .vsixmanifest file
* * Optional, you can work with .git folder for getting information about branch - sha1, name, etc..

It's easy (time etc.) and examples of basic implementation, you can found in [current repository](https://bitbucket.org/3F/vssolutionbuildevent/src)

After implementing, we can work with this utility in vsSBE

### Step 2. Settings vsSBE ###

* Select event type - "Pre-Build".
* Change "Processing mode" to Interpreter Mode
* Activate MSBuild support
* In 'Execution Order', find and select your implemented utility (in example - it's Version) - Activate and set range as "After"
* Interpreter settings: 
* * Simple "cmd.exe /C"
* * Wrapper & modification lines - should be as empty
* Enable - "Waiting for completion"

Your utility can receive some arguments(for reuse later), so you can write the next script, for example:


```
#!bash

$(sln = $(SolutionDir.Replace('\', '/')))

$(TargetPath:Version) 
  $(Configuration) 
  "$(sln)" 
  "Version/Version.tpl" 
  "vsSolutionBuildEvent/Version.cs" 
  "vsSolutionBuildEvent/source.extension.vsixmanifest" 
```

and similar..

Activate event and click apply

### Result ###

Now we have the next result:

* Before building the all projects in your solution ↓ 
* Only after completed building the Version utility ↓ 
* Should automatically:
* * Generating Version.cs with properties of version, sha1 and other
* * Updating .vsixmanifest
* After completed → building the remaining projects in the solution. Done.

# References #

* [Examples of basic usage - scripts, solutions, etc., ](http://visualstudiogallery.msdn.microsoft.com/0d1dbfd7-ed8a-40af-ae39-281bfeca2334/)